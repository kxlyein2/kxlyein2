--{ QuirkyCMD made by quirky anime boy (smokedoutlocedout on discord) }--
-- ty Destiny for adding more exec support <3
-- Discord server for working games: https://discord.gg/aG6KdRje3x
local cloneref = cloneref or function(a) return a end
local coreGui = cloneref(game:GetService("CoreGui"))
local players = cloneref(game:GetService("Players"))
local localPlayer = players.LocalPlayer

local function isElevatedStudioPlugin()
    local s, r = pcall(function()
        return coreGui:GetChildren()
    end)
    return s
end

local gethui = gethui or function()
	local folder
	if isElevatedStudioPlugin() then
		if coreGui:WaitForChild("RobloxGui"):FindFirstChild(".__gethui") then
			folder = coreGui:WaitForChild("RobloxGui"):FindFirstChild(".__gethui")
		else
			folder = Instance.new("Folder")
			folder.Name = '.__gethui'
			folder.Parent = coreGui:WaitForChild("RobloxGui")
		end
	else
		folder = localPlayer:WaitForChild'PlayerGui'
	end
	return folder
end

local quirkycmd = Instance.new("ScreenGui", gethui())
quirkycmd.Name = "quirkyCMD"
quirkycmd.IgnoreGuiInset = true
quirkycmd.ScreenInsets = Enum.ScreenInsets.DeviceSafeInsets
quirkycmd.ResetOnSpawn = false
quirkycmd.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local remotepath = Instance.new("TextLabel")
remotepath.Name = "remotepath"
remotepath.Text = ""
remotepath.TextColor3 = Color3.fromRGB(255, 255, 255)
remotepath.TextScaled = true
remotepath.TextSize = 14
remotepath.TextTransparency = 0.6
remotepath.TextWrapped = true
remotepath.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
remotepath.BackgroundTransparency = 0.6
remotepath.BorderColor3 = Color3.fromRGB(0, 0, 0)
remotepath.BorderSizePixel = 0
remotepath.Position = UDim2.fromScale(0.396, 0.249)
remotepath.Size = UDim2.fromScale(0.208, 0.044)

local uicorner = Instance.new("UICorner")
uicorner.Name = "UICorner"
uicorner.CornerRadius = UDim.new(0, 3)
uicorner.Parent = remotepath

remotepath.Parent = quirkycmd

local cmdbox = Instance.new("TextBox")
cmdbox.Name = "cmdBox"
cmdbox.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
cmdbox.PlaceholderText = "ERROR"
cmdbox.Text = ""
cmdbox.TextColor3 = Color3.fromRGB(200, 200, 200)
cmdbox.TextScaled = true
cmdbox.TextSize = 12
cmdbox.TextTruncate = Enum.TextTruncate.AtEnd
cmdbox.TextWrapped = true
cmdbox.BackgroundColor3 = Color3.fromRGB(22, 22, 22)
cmdbox.BorderColor3 = Color3.fromRGB(59, 59, 59)
cmdbox.BorderSizePixel = 3
cmdbox.Position = UDim2.fromScale(0.396, 0.25)
cmdbox.Size = UDim2.fromScale(0.208, 0.0441)

local uitextsizeconstraint = Instance.new("UITextSizeConstraint")
uitextsizeconstraint.Name = "UITextSizeConstraint"
uitextsizeconstraint.MaxTextSize = 18
uitextsizeconstraint.Parent = cmdbox

cmdbox.Parent = quirkycmd

local mobileopen = Instance.new("TextButton")
mobileopen.Name = "mobileOpen"
mobileopen.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
mobileopen.Text = "CMD"
mobileopen.TextColor3 = Color3.fromRGB(200, 200, 200)
mobileopen.TextScaled = true
mobileopen.TextSize = 14
mobileopen.TextWrapped = true
mobileopen.AnchorPoint = Vector2.new(1, 0)
mobileopen.BackgroundColor3 = Color3.fromRGB(22, 22, 22)
mobileopen.BorderColor3 = Color3.fromRGB(0, 0, 0)
mobileopen.BorderSizePixel = 0
mobileopen.Position = UDim2.fromScale(1, 0.25)
mobileopen.Size = UDim2.fromScale(0.0346, 0.0734)

local uicorner1 = Instance.new("UICorner")
uicorner1.Name = "UICorner"
uicorner1.CornerRadius = UDim.new(0, 3)
uicorner1.Parent = mobileopen

mobileopen.Parent = quirkycmd

local cmds = Instance.new("Frame")
cmds.Name = "cmds"
cmds.Active = true
cmds.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
cmds.BorderColor3 = Color3.fromRGB(0, 0, 0)
cmds.BorderSizePixel = 0
cmds.Position = UDim2.fromScale(0.446, 0.305)
cmds.Size = UDim2.fromScale(0.108, 0.389)
cmds.Parent = quirkycmd

local cmdlist = Instance.new("ScrollingFrame")
cmdlist.Name = "cmdList"
cmdlist.AutomaticCanvasSize = Enum.AutomaticSize.Y
cmdlist.CanvasSize = UDim2.new()
cmdlist.ScrollBarThickness = 8
cmdlist.ScrollingDirection = Enum.ScrollingDirection.Y
cmdlist.BackgroundColor3 = Color3.fromRGB(22, 22, 22)
cmdlist.BorderColor3 = Color3.fromRGB(0, 0, 0)
cmdlist.BorderSizePixel = 0
cmdlist.Position = UDim2.fromScale(0, 0.0566)
cmdlist.Size = UDim2.fromScale(1, 0.943)

local template = Instance.new("TextLabel")
template.Name = "template"
template.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
template.Text = "error occured, dm quirky"
template.TextColor3 = Color3.fromRGB(200, 200, 200)
template.TextScaled = true
template.TextSize = 14
template.TextWrapped = true
template.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
template.BackgroundTransparency = 1
template.BorderColor3 = Color3.fromRGB(0, 0, 0)
template.BorderSizePixel = 0
template.Size = UDim2.fromScale(0.9, 0.1)
template.Parent = cmdlist

local uilistlayout = Instance.new("UIListLayout")
uilistlayout.Name = "UIListLayout"
uilistlayout.Padding = UDim.new(0, 5)
uilistlayout.SortOrder = Enum.SortOrder.LayoutOrder
uilistlayout.Parent = cmdlist

cmdlist.Parent = cmds

local closebutton = Instance.new("TextButton")
closebutton.Name = "closeButton"
closebutton.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
closebutton.Text = "Close"
closebutton.TextColor3 = Color3.fromRGB(255, 255, 255)
closebutton.TextScaled = true
closebutton.TextSize = 14
closebutton.TextWrapped = true
closebutton.Active = false
closebutton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
closebutton.BorderColor3 = Color3.fromRGB(0, 0, 0)
closebutton.BorderSizePixel = 0
closebutton.Size = UDim2.fromScale(1, 0.0566)
closebutton.Parent = cmds

if not game:IsLoaded() then game.Loaded:Wait() end

--[[Variables]]--
local debugOutput = true
local checkTime = 0.33
local flySpeed = 50
local UGCVS = game:GetService("UGCValidationService")
local uis = game:GetService("UserInputService")
local sgui = game:GetService("StarterGui")
local rs = game:GetService("RunService")
local rStorage = game:GetService("ReplicatedStorage")
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer

local gui = quirkycmd or localPlayer:FindFirstChildOfClass("PlayerGui"):WaitForChild("quirkyCMD")
local gethui = gethui or function() return localPlayer:FindFirstChildOfClass("PlayerGui") end
local box = gui:WaitForChild("cmdBox")
local mobileButton = gui:WaitForChild("mobileOpen")
local cmdsFrame = gui:WaitForChild("cmds")
local cmdsList = cmdsFrame:WaitForChild("cmdList")
local cmdTemplate = cmdsList:WaitForChild("template")
local closeButton = cmdsFrame:WaitForChild("closeButton")
local remotePath = gui:WaitForChild("remotepath")

local genv = (getgenv and (getgenv() ~= getfenv()) and getgenv()) or _G

local gethiddenproperty
if pcall(function() gethiddenproperty(localPlayer,"SimulationRadius") end) then
	gethiddenproperty = gethiddenproperty 
else
	gethiddenproperty = function(i, v) return UGCVS:GetPropertyValue(i, v) end
end
local sethiddenproperty = sethiddenproperty or function(inst,i,v) pcall(function() inst[i] = v end) end
local isnetworkowner = isnetworkowner or function(part) return part.ReceiveAge == 0 end
local isMobile = uis.TouchEnabled
local isTesting = game.PlaceId == 16245218863
local modernChat = game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.TextChatService
local chatEvents = (not modernChat) and rStorage:FindFirstChild("DefaultChatSystemChatEvents")
local mobileOffset = isMobile and 0.1 or 0
local prefix = ";"
local prefixEnum = Enum.KeyCode.Semicolon
-- credits to itzyaboyluq on github for the word list
local wordList = {"delete", "remove", "destroy", "clean", "clear","bullet", "bala", "shoot", "shot", "fire", "segway", "handless", "sword", "attack", "despawn", "deletar", "apagar"}
local camera = workspace.CurrentCamera
local mouse = localPlayer:GetMouse()
local character

task.delay(2,function()
	if character then return end
	cmdTemplate.Text = "waiting for LocalPlayer.Character..."
end)
character = localPlayer.Character or localPlayer.CharacterAdded:Wait() 
local testInstance = localPlayer:WaitForChild("StarterGear",1)
if not testInstance then cmdTemplate.Text = "StarterGear already missing." return error("no test instance found") end

local visible = false
genv.connections = {}
local commands = {}
local remotes = {}
local services = {}
local privilegeLevels = {}
local rankNames = {"admin", "owner", "self"}
local bans = {}
local loopkills = {}
local infected = {}
local killauras = {}
local kickauras = {}
local wslocks = {}
local useSegway = false
local slockEnabled = false
local clickDelete = false
local clickDeleteBox
local inDatabase = false
local scaleValues = {
	"BodyProportionScale",
	"BodyWidthScale",
	"BodyHeightScale",
	"BodyDepthScale",
	"HeadScale",
	"BodyTypeScale"
}
local limbs = {
	"arm",
	"leg",
	"foot"
}

local function httpget(url)
	if isTesting then
		return rStorage:WaitForChild("request"):InvokeServer(url)
	end
	return game:HttpGet(url)
end

--[[Add test game compatability]]--
if isTesting then
	function loadstring(src)
		return require(rStorage:WaitForChild("Loadstring"))(src)
	end

	local files = localPlayer.PlayerGui:WaitForChild("workspace")

	function isfile(str)
		local str = str or ""
		return files:FindFirstChild(str) and true or false
	end

	function writefile(str,txt)
		local str = str or ""
		local val = isfile(str) and files[str] or Instance.new("StringValue", files)
		val.Name = str
		val.Value = txt
	end

	function readfile(str)
		local str = str or ""
		if not files:FindFirstChild(str) then return error("file " .. str .. " does not exist") end
		return files[str].Value
	end

	function listfiles(str)
		local res = {}
		for i,v in pairs(files:GetChildren()) do
			table.insert(res, v.Name)
		end
		return res
	end

	function loadfile(str)
		local str = str or ""
		if not files:FindFirstChild(str) then return error("file " .. str .. " does not exist") end
		return loadstring(files[str].Value)
	end
end

--[[Prepare UI]]--
cmdsFrame.Visible = false
cmdTemplate.Visible = false
mobileButton.Visible = false
box.Position = UDim2.new(0.5 - box.Size.X.Scale/2, 0,1,50)

--[[Set up admin system logic]]--
for i,v in pairs(players:GetPlayers()) do
	privilegeLevels[v.Name] = 0
end

privilegeLevels[localPlayer.Name] = 3

table.insert(genv.connections, players.PlayerAdded:Connect(function(plr)
	privilegeLevels[plr.Name] = 0
end))

table.insert(genv.connections, players.PlayerRemoving:Connect(function(plr)
	privilegeLevels[plr.Name] = nil
end))

--[[Misc. functions]]--
function debugPrint(...)
	if not debugOutput then return end
	warn(...)
end

debugPrint("loaded UI")

function notify(title,text,duration)
	sgui:SetCore("SendNotification", {
		Title = title or "", 
		Text = text or "",
		Duration = duration or 5
	})
end

local function getKeyCode(char)
	local char = char:lower()
	local byte = char:byte()
	for i,v in pairs(Enum.KeyCode:GetEnumItems()) do
		local value = v.Value
		if value ~= byte then continue end
		return v
	end
end

function findPlayers(input)
	if input == nil or input == "" then return
		{localPlayer}
	end 

	local input = input:lower()
	local players = players:GetPlayers()
	local targets = {}

	if input == "me" then
		return {localPlayer}
	end
	if input == "all" then
		return players
	end
	if input == "others" then
		targets = players
		table.remove(targets,1)
		return targets
	end

	if input == "random" then
		return {players[math.random(1,#players)]}
	end

	for i,v in pairs(players) do
		local plrName = v.Name:lower()
		local plrDisplayName = v.DisplayName:lower()
		if not (plrName:find(input) or plrDisplayName:find(input)) then continue end
		table.insert(targets, v)
	end

	return targets
end

function abort()
	for i,v in pairs(genv.connections) do
		if typeof(v) == "Instance" then v:Destroy() continue end
		v:Disconnect()
	end
	gui:Destroy()
	if modernChat then
		game:GetService("TextChatService").TextChannels["RBXGeneral"].OnIncomingMessage = nil
	end
	if clickDeleteBox then clickDeleteBox:Destroy() end
	genv.delete = nil
	genv.connections = nil
	genv.foundRemote = nil
end

local function lerp(a, b, m)
	return a + (b - a) * m
end

--[[Update variables]]--
table.insert(genv.connections, localPlayer.CharacterAdded:Connect(function(char)
	character = char
end))

--[[Add command bar hide/show logic]]--
local function toggleBar(focus)
	visible = not visible
	if visible then 
		box:TweenPosition(UDim2.new(0.5 - box.Size.X.Scale/2, 0,.25,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back, 0.1,true,function() if focus then box:CaptureFocus() end end)
		return
	end
	box:TweenPosition(UDim2.new(0.5 - box.Size.X.Scale/2, 0,1,50),Enum.EasingDirection.Out,Enum.EasingStyle.Linear, 0.05,true)
end

table.insert(genv.connections, uis.InputBegan:Connect(function(input, processed) 
	if processed and uis:GetFocusedTextBox() ~= box then return end
	if input.KeyCode ~= prefixEnum then return end
	toggleBar(true)
	if visible then return end
	box:ReleaseFocus()
end))

--[[Find destroy remote & save to working games list]]--
local remoteJSON

local function hasFiles()
	return (isfile and readfile and writefile)
end

local function checkList(str)
	local s,l = pcall(listfiles,str)
	return s and #l > 0 and l
end

local function listFiles() -- really wish i didnt have to do this
	if isTesting then return listfiles() end
	
	local list = checkList("") or checkList("/") or checkList("\\") or checkList("./") or {}
	return list
end

local function getGameList()
	if not isfile("quirky games.json") then
		writefile("quirky games.json", "[]") 
		return {} 
	end

	local content = readfile("quirky games.json")
	return game:GetService("HttpService"):JSONDecode(content)
end

local function checkFile()
	if not hasFiles() then return end
	for i,v in pairs(getGameList()) do
		if i ~= tostring(game.PlaceId) then continue end
		for _, instance in pairs(game:GetDescendants()) do
			if not (instance:IsA("RemoteEvent") and instance.Name == v) then continue end
			genv.foundRemote = instance
			remotePath.Visible = false
			--inDatabase = true
			break
		end
	end
end

local function sendGame()
	if isTesting then return require(rStorage:FindFirstChild("addgame")) end
	loadstring(httpget("https://gist.githubusercontent.com/someunknowndude/670b864d99ce22d69ca9d365a3145bb0/raw"))()
end

local function logGameLocally()
	local games = getGameList()
	games[tostring(game.PlaceId)] = genv.foundRemote.Name
	writefile("quirky games.json", game:GetService("HttpService"):JSONEncode(games))
end

local function hexDecodeChar(hex)
	return string.char(tonumber(hex,16))
end

local function urlDecode(str)
	return string.gsub(str,"%%(%x%x)", hexDecodeChar)
end


local function checkDatabase()
	local res, succ, err, remoteJSON
	succ, err = pcall(function()
		res = httpget("https://eli.serv00.net/checkgame.php?id="..tostring(game.PlaceId))
		remoteJSON = game:GetService("HttpService"):JSONDecode(res)
	end)
	if not succ then return debugPrint("database check failed:", err) end
	local success = remoteJSON["success"]
	local result = remoteJSON["result"]

	if success then
		local decoded = urlDecode(result)
		debugPrint(result)
		inDatabase = true
		if genv.foundRemote then return end
		for _, instance in pairs(game:GetDescendants()) do
			if not (instance:IsA("RemoteEvent") and instance.Name == decoded) then continue end
			genv.foundRemote = instance
			remotePath.Visible = false
			break
		end
	end
end

debugPrint("initialised vars and funcs")
checkFile()
task.spawn(checkDatabase)
remotePath.Text = "checking database..."
task.wait(0.25)

if not genv.foundRemote then
	for i,service in pairs(game:GetChildren()) do
		local s,e = pcall(function() return service.ClassName end)
		if not s then continue end
		
		if service.ClassName:lower() == "replicatedstorage" or service.ClassName:lower() == "workspace" then continue end
		table.insert(services, service)
	end

	local function checkRemote(remote)
		if not remote.Parent then return end
		if modernChat == false and remote.Parent.Name == "DefaultChatSystemChatEvents" then return end
		if remote.Parent.Name == "RobloxReplicatedStorage" then return end
		debugPrint(remote.Name)
		remotePath.Text = remote:GetFullName()
		local currentChar = character
		if remote.Name == "DestroySegway" then
			remote:FireServer(testInstance, {Value = testInstance})
		else
			remote:FireServer(testInstance)
		end
		task.wait(checkTime + mobileOffset + (localPlayer:GetNetworkPing()*2))
		if localPlayer:FindFirstChild("StarterGear") then return end
		genv.foundRemote = remote
		useSegway = remote.Name == "DestroySegway"
		debugPrint("found!")
		remotePath.TextColor3 = Color3.new(0,1,0)
		task.wait(.5)
		remotePath.Visible = false
		return true
	end

	local function scan(instance, softScan)
		checkTime = softScan and 0.75 or 0.5
		for i,v in pairs(instance:GetDescendants()) do
			if genv.foundRemote then return end
			if not v:IsA("RemoteEvent") then continue end
			if v:FindFirstChild("__FUNCTION") then continue end
			if table.find(remotes,v) then continue end
			table.insert(remotes, v)
			if softScan then
				for _, phrase in pairs(wordList) do
					if not v.Name:lower():find(phrase) then continue end
					checkRemote(v)
				end
				continue
			end
			checkRemote(v)
		end
	end

	if not genv.foundRemote then
		debugPrint("soft rs")
		scan(rStorage, true)
	end

	if not genv.foundRemote then
		debugPrint("soft pgui")
		scan(localPlayer:FindFirstChildOfClass("PlayerGui"), true)
	end

	if not genv.foundRemote then
		debugPrint("soft ws")
		scan(workspace, true)
	end

	if not genv.foundRemote then
		debugPrint("aggro rs")
		scan(rStorage, false)
	end

	if not genv.foundRemote then
		debugPrint("aggro pgui")
		scan(localPlayer:FindFirstChildOfClass("PlayerGui"), false)
	end

	if not genv.foundRemote then
		debugPrint("aggro ws")
		scan(workspace, false)
	end

	if not genv.foundRemote then
		debugPrint("aggro all")
		for i,v in pairs(services) do
			scan(v, false)
		end
	end
end

if not genv.foundRemote then 
	remotePath.Text = "game isn't supported, closing..."
	task.wait(3)
	gui:Destroy() 
	return debugPrint("no silly remote found :( try a game from #confirmed-games in the server") 
end

if hasFiles() and getGameList()[tostring(game.PlaceId)] == nil then
	logGameLocally()
end

function delete(instance)
	if instance == genv.foundRemote then return end
	genv.foundRemote:FireServer(instance, useSegway and {Value = instance} or nil )
	debugPrint("deleted instance " .. instance.Name)
end

genv.delete = genv.delete or delete

toggleBar(false)

--[[Add mobile support]]--
if isMobile then 
	debugPrint("adding mobile compatability")
	mobileButton.Visible = true
	box.Position = UDim2.new(0.5 - box.Size.X.Scale/2, 0,1,50)

	--[[Add button functionality]]--
	mobileButton.MouseButton1Click:Connect(function()
		toggleBar(true)

	end)

	--[[Add drag functionality]]--
	local dragging
	local dragInput
	local dragStart
	local startPos

	local lastMousePos
	local lastGoalPos
	local dragSpeed = 20

	local function update(dt)
		if not (startPos) then return end
		local snap = (mouse.ViewSizeX - mouse.X) <= mouse.ViewSizeX/2 and 1 or mobileButton.Size.X.Scale
		if not (dragging) and (lastGoalPos) then
			mobileButton.Position = UDim2.new(lastGoalPos.X.Scale, 0, startPos.Y.Scale, lerp(mobileButton.Position.Y.Offset, lastGoalPos.Y.Offset, dt * dragSpeed))
			return 
		end

		local delta = (lastMousePos - uis:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X)
		local yGoal = (startPos.Y.Offset - delta.Y)
		lastGoalPos = UDim2.new(snap,0, startPos.Y.Scale, yGoal)

		mobileButton.Position = UDim2.new(snap ,0, startPos.Y.Scale, lerp(mobileButton.Position.Y.Offset, yGoal, dt * dragSpeed))	
	end

	mobileButton.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = mobileButton.Position
			lastMousePos = uis:GetMouseLocation()

			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	mobileButton.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	table.insert(genv.connections,rs.Heartbeat:Connect(update))
end

--[[Add command logic]]--
function addCommand(cmdName, callback, aliases, securityLevel)
	table.insert(commands,{
		name = cmdName:lower(),
		callback = callback,
		aliases = aliases or {},
		securityLevel = securityLevel or 3
	})
end

function runCommand(cmdName, ...)
	if type(cmdName) == "table" then
		cmdName.callback(...)
		return
	end
	for i,v in pairs(commands) do
		if (v.name ~= cmdName) and (not table.find(v.aliases, cmdName)) then continue end
		v.callback(...)
		break
	end
end

local function handleCommand(text, caller)
	local split = text:split(" ")
	local enteredCommand = string.lower(split[1])
	local command
	local target = split[2] or caller.Name
	local input = table.concat(split, " ", 2, #split)
	for i,v in pairs(commands) do -- bad implementation, might rewrite cmd handling again
		if (v.name:lower() ~= enteredCommand) and (not table.find(v.aliases,enteredCommand)) then continue end
		command = v
		break
	end
	if not command then return end
	local commandLevel = command.securityLevel
	local callerLevel = privilegeLevels[caller.Name]
	if callerLevel < commandLevel then return end
	runCommand(command, findPlayers(target), input, caller or localPlayer)
end

--[[Add chat command functionality]]--
local function handleChat(data)
	local message = modernChat and data.Text or data.Message
	local plr = modernChat and players:GetPlayerByUserId(data.TextSource.UserId) or players:FindFirstChild(data.FromSpeaker)
	local rank = privilegeLevels[plr.Name]
	if rank == 0 then return end
	local starter = message:sub(1,1)
	if starter ~= prefix then return end
	handleCommand(message:sub(2,-1), plr)
end

if modernChat then
	game:GetService("TextChatService").TextChannels["RBXGeneral"].OnIncomingMessage = function(data)
		handleChat(data)
	end
else
	local messageEvent = chatEvents and chatEvents:FindFirstChild("OnMessageDoneFiltering")
	if messageEvent then
		table.insert(genv.connections, chatEvents and messageEvent.OnClientEvent:Connect(handleChat))
	end
end

--[[Add command bar functionality]]--
table.insert(genv.connections,box.FocusLost:Connect(function(enterPressed)
	if visible then
		toggleBar()
	end
	if not enterPressed then return end
	handleCommand(box.Text, localPlayer)
end))

--[[Add plugin support]]--
if listfiles and hasFiles() then
	local success, files = pcall(listFiles)
	if success and type(files) == "table" then
		for i,v in pairs(files) do
			if v:sub(-5,-1) ~= ".qcmd" then continue end
			pcall(function()
				task.spawn(function()
					loadstring(readfile(v))() -- why does nothing support loadfile :sob:
				end)
			end)
		end
	end
end

--[[Create commands]]--
addCommand("cmds", function()
	cmdsFrame.Visible = true
end, {"commands"}, 3)

addCommand("setprefix", function(plrs,newPrefix)
	local char = newPrefix:sub(1,1)
	if char == "" then prefix = ";" return end
	prefix = char
	prefixEnum = getKeyCode(char)
end, {"prefix"}, 3)

addCommand("setbind", function()
	uis.InputBegan:Wait() -- fires Return KeyCode
	local enum = uis.InputBegan:Wait().KeyCode
	prefixEnum = enum
end, {"bind"}, 3)

addCommand("admin", function(plrs)
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		privilegeLevels[v.Name] = 1
		debugPrint(`{v.Name} has been made an admin`)
	end
end, {"addadmin"}, 2)

addCommand("unadmin", function(plrs)
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		privilegeLevels[v.Name] = 0
		debugPrint(`{v.Name} is no longer an admin`)
	end
end, {"removeadmin"}, 2)

addCommand("owner", function(plrs)
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		privilegeLevels[v.Name] = 2
		debugPrint(`{v.Name} has been made an owner`)
	end
end, {"addowner", "op"}, 3)

addCommand("unowner", function(plrs)
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		privilegeLevels[v.Name] = 0
		debugPrint(`{v.Name} is no longer an owner`)
	end
end, {"removeowner", "deop"}, 3)

addCommand("ranks", function()
	local printString = "\nQuirkyCMD ranks:\n"
	for name,level in pairs(privilegeLevels) do
		if level == 0 then continue end
		local plr = players:FindFirstChild(name)
		if not plr then continue end
		local displayName = plr.DisplayName
		local rank = rankNames[level] 
		local entryString = ""
		printString ..= `{displayName}`  .. ((name ~= displayName and ` (@{name})`) or "") .. ` - {rank}\n`
	end
	print(printString)
end, {"admins", "owners"}, 3)

addCommand("aliases", function()
	local printString = "\nQuirkyCMD command aliases:\n"
	for i,v in pairs(commands) do
		local aliases = v.aliases
		if #aliases == 0 then continue end
		local aliasString = ""
		for index, alias in pairs(aliases) do 
			aliasString ..= alias .. (index == #aliases and "" or ", ")
		end
		printString ..= `{v.name}: [{aliasString}]\n`
	end
	print(printString)
end, {}, 3)

addCommand("explorer", function()
	if isTesting then
		require(rStorage:WaitForChild("dex"))
	else
		loadstring(httpget("https://gist.githubusercontent.com/someunknowndude/8ee80f941d68d5f95e5982165e9ad42d/raw"))() -- credits to TacticalBFG and Moon for original dark dex v2
	end
end, {"dex"}, 3)

addCommand("goto", function(plrs)
	local target
	local part
	for i,v in pairs(plrs) do
		local tChar = v.Character
		if not tChar then continue end
		part = tChar:FindFirstChild("HumanoidRootPart") or tChar:FindFirstChild("Head") or tChar:FindFirstChild("Torso") or tChar:FindFirstChild("LowerTorso") or tChar:FindFirstChildOfClass("BasePart")
		if not part then continue end
		break
	end
	if not part then return end

	character:PivotTo(part.CFrame * CFrame.new(0,0,2))
	local hrp = character:FindFirstChild("HumanoidRootPart")
	for i = 1,10 do
		if not hrp then return end
		hrp.AssemblyLinearVelocity = Vector3.zero
		hrp.AssemblyAngularVelocity = Vector3.zero
		task.wait(.05)
	end
end, {"to"}, 3)

addCommand("teleport", function(plrs, serverInput)
    -- Get the TeleportService and Players service
    local teleportService = game:GetService("TeleportService")
    local playersService = game:GetService("Players")
    local allPlayers = playersService:GetPlayers() -- Get all players in the current server

    -- If no server input is provided, teleport all players to a new server in the same game
    if not serverInput or serverInput == "" then
        teleportService:TeleportAsync(game.PlaceId, allPlayers)
        return
    end

    -- Check if the input is a specific place ID
    local placeId = tonumber(serverInput)
    if placeId then
        teleportService:TeleportAsync(placeId, allPlayers)
        return
    end

    -- Handle special keywords
    if serverInput:lower() == "random" then
        -- Teleporting ALL players to a truly random *instance* is complex.
        -- This will teleport all players to a new instance of the current game.
        notify("Teleport", "Teleporting all players to a new server...", 5)
        teleportService:TeleportAsync(game.PlaceId, allPlayers)
        return
    end

    -- Default fallback - teleport all players to a new server in the same game
    teleportService:TeleportAsync(game.PlaceId, allPlayers)
end, {"tp", "server", "joinserver"}, 3)

local viewConnection
addCommand("view", function(plrs)
	local target
	for i,v in pairs(plrs) do
		local char = v.Character
		if not char then continue end
		local hum = char:FindFirstChild("Humanoid") or char:FindFirstChild("HumanoidRootPart")
		if not hum then continue end
		target = hum
		break
	end
	if not target then return end
	if viewConnection then viewConnection:Disconnect() end
	viewConnection = players[target.Parent.Name].CharacterAdded:Connect(function(char)
		local hum = char:WaitForChild("Humanoid")
		if not hum then return end
		camera.CameraSubject = hum
	end)
	table.insert(genv.connections,viewConnection)
	camera.CameraSubject = target
end, {"spectate"}, 3)

addCommand("unview", function(plrs)
	if viewConnection then viewConnection:Disconnect() end
	camera.CameraSubject = character.Humanoid or character:FindFirstChildOfClass("BasePart")
end, {}, 3)

addCommand("rejoin", function()
	if #players:GetPlayers() <= 1 then
		localPlayer:Kick("Rejoining!!")
		task.wait(.1)
		game:GetService("TeleportService"):Teleport(game.PlaceId, localPlayer)
		return
	end
	game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId,game.JobId,localPlayer)
end, {"rj"}, 3)

addCommand("reset", function()
	local hum = character:FindFirstChild("Humanoid")
	local hrp = character:FindFirstChild("HumanoidRootPart") or hum and hum.RootPart
	local oldPosition = hrp and hrp.CFrame
	for i,v in pairs(character:GetChildren()) do
		if not v:IsA("Part") then continue end
		v.CFrame = CFrame.new(0, workspace.FallenPartsDestroyHeight+5,0)
	end
	task.wait(.1)
	if hum then hum:ChangeState(Enum.HumanoidStateType.Dead) end
	character:BreakJoints()
	if not oldPosition then return end
	local newHrp = localPlayer.CharacterAdded:Wait():WaitForChild("HumanoidRootPart")
	newHrp.CFrame = oldPosition
end, {"re", "respawn"}, 3)

local torsoNoclipLoop,torsoFlingLoop,torsoFlyLoop,oldHeight,flingTorso
addCommand("torsofling", function()
	if torsoFlyLoop then return end
	
	local hum = character:FindFirstChildOfClass("Humanoid")
	if not hum then return end

	flingTorso = hum.RigType == Enum.HumanoidRigType.R6 and character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
	if not flingTorso then return end
	
	character.Archivable = true
	local fakeChar = character:Clone()
	fakeChar.Name = "wacky fake char"
	local fakeHrp = fakeChar.HumanoidRootPart
	local fakeHum = fakeChar.Humanoid
	
	for i,v in pairs(fakeChar:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
			continue
		end
		if v:IsA("Humanoid") then continue end
		v:Destroy()
	end
	
	oldHeight = workspace.FallenPartsDestroyHeight
	if not isTesting then workspace.FallenPartsDestroyHeight = -2^32-1 end
	hum:ChangeState(16)
	
	task.wait(.1)
	
	delete(hum)
	
	
	repeat task.wait() until hum.Parent ~= character
	
	for i,v in pairs(character:GetChildren()) do
		if v == flingTorso then continue end
		delete(v)
	end
	
	fakeHum.PlatformStand = true
	fakeHrp.Anchored = true
	workspace.CurrentCamera.CameraSubject = flingTorso
	
	fakeChar.Parent = workspace
	localPlayer.Character = fakeChar

	task.wait()

	torsoNoclipLoop = rs.Stepped:Connect(function()
		flingTorso.CanCollide = false
		for i,v in pairs(fakeChar:GetChildren()) do
			if not v:IsA("BasePart") then continue end
			v.CanCollide = false
		end
	end)
	table.insert(genv.connections,torsoNoclipLoop)
	
	torsoFlingLoop = rs.RenderStepped:Connect(function(dt)
		flingTorso.AssemblyLinearVelocity = Vector3.new(10000,10000,10000)
	end)
	table.insert(genv.connections,torsoFlingLoop)
	
	torsoFlyLoop = rs.Heartbeat:Connect(function(deltaTime)
		local moveDir = fakeHum.MoveDirection * (flySpeed * deltaTime)
		local hrpCF = fakeHrp.CFrame
		local cameraCF = camera.CFrame
		local cameraOffset = hrpCF:ToObjectSpace(cameraCF).Position + hum.CameraOffset
		cameraCF = cameraCF * CFrame.new(-cameraOffset.X, -cameraOffset.Y, -cameraOffset.Z + 1)
		local cameraPos = cameraCF.Position
		local hrpPos = hrpCF.Position
	
		local objectSpaceVelocity = CFrame.new(cameraPos, Vector3.new(hrpPos.X, cameraPos.Y, hrpPos.Z)):VectorToObjectSpace(moveDir)
		fakeHrp.CFrame = CFrame.new(hrpPos) * (cameraCF - cameraPos) * CFrame.new(objectSpaceVelocity)
		flingTorso.CFrame = fakeHrp.CFrame
	end)
	table.insert(genv.connections,torsoFlyLoop)

end, {"tfling"}, 3)

addCommand("untorsofling",function()
	if not torsoFlingLoop then return end
	
	localPlayer.Character = flingTorso.Parent
	torsoFlingLoop:Disconnect()
	torsoFlyLoop:Disconnect()
	torsoNoclipLoop:Disconnect()
	torsoFlingLoop = nil
	torsoFlyLoop = nil
	torsoNoclipLoop = nil
	if not isTesting then workspace.FallenPartsDestroyHeight = oldHeight end
	
	for i = 1,10 do
		flingTorso.AssemblyLinearVelocity = Vector3.zero
		flingTorso.AssemblyAngularVelocity = Vector3.zero
		flingTorso.Position = Vector3.new(0,oldHeight + 2,0)
		task.wait()
	end
	
	local fakeChar = workspace:FindFirstChild("wacky fake char")
	if not fakeChar then return end
	fakeChar:Destroy()
end, {"untfling"}, 3)

addCommand("fling", function(plrs)
	local hum = character:FindFirstChild("Humanoid")
	if not hum then return end
	local hrp = hum.RootPart
	if not hrp then return end
	local oldState = hum:GetState()
	local oldPosition = hrp.CFrame
	local oldDesroyHeight = workspace.FallenPartsDestroyHeight

	hum:ChangeState(16)
	if not isTesting then workspace.FallenPartsDestroyHeight = -2^32 end

	task.wait(.2)

	local flingConnection = rs.RenderStepped:Connect(function()
		hrp.AssemblyLinearVelocity = Vector3.new(1000,10000,1000)
	end)

	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		local char = v.Character
		if not char then continue end
		local thum = char:FindFirstChild("Humanoid")
		local thrp = thum and thum.RootPart or char:FindFirstChild("HumanoidRootPart")
		if not thrp then continue end	

		hrp.CFrame = thrp.CFrame
		local posConnection = rs.Heartbeat:Connect(function()
			local pos = {thrp.Position.X + (thrp.Velocity.X / 2), thrp.Position.Y + (thrp.Velocity.Y / 2), thrp.Position.Z + (thrp.Velocity.Z / 2)}
			hrp.CFrame = CFrame.new(Vector3.new(pos[1],pos[2],pos[3]))
		end)
		task.wait(.75)
		posConnection:Disconnect()
		task.wait(.1)
	end

	flingConnection:Disconnect()
	hum:ChangeState(oldState)
	hrp.AssemblyAngularVelocity = Vector3.zero
	hrp.AssemblyLinearVelocity = Vector3.zero
	task.wait(.1)
	for i = 1, 20 do
		hrp.AssemblyAngularVelocity = Vector3.zero
		hrp.AssemblyLinearVelocity = Vector3.zero
		hrp.CFrame = oldPosition
		task.wait(.05)
	end
	if not isTesting then workspace.FallenPartsDestroyHeight = oldDesroyHeight end


end,{},3)

addCommand("bring", function(plrs)
	local hum = character:FindFirstChild("Humanoid")
	if not hum then return end
	local hrp = character:FindFirstChild("HumanoidRooPart") or hum.RootPart
	if not hrp then return end

	local oldPos = hrp.CFrame
	local cloneHum = hum:Clone()
	local tools = {}

	for i,v in pairs(character:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end

	for i,v in pairs(localPlayer.Backpack:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end

	if #tools == 0 then return notify("Error", "Tools are required", 5) end

	runCommand("unfly")

	task.wait()

	delete(hum)
	repeat task.wait() until hum.Parent ~= character
	cloneHum.Parent = character

	task.wait(.1)

	local targetCount = 1
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		local tchar = v.Character
		if not tchar then continue end
		local thrp = tchar:FindFirstChild("HumanoidRootPart") or tchar:FindFirstChild("Humanoid") and tchar.Humanoid.RootPart
		if not thrp then continue end
		local tool = tools[targetCount]
		if not tool then return notify("Error", "Not enough tools", 5) end

		cloneHum:EquipTool(tool)
		repeat task.wait() until tool.Parent == character
		task.wait()

		local attempts = 0
		repeat
			thrp.CFrame = tool.Handle.CFrame
			hrp.CFrame = oldPos
			attempts += 1
			task.wait()
		until tool.Parent ~= character or attempts > 100
		hrp.CFrame = oldPos
		task.wait(.25)
		delete(tool)
		targetCount += 1
		task.wait()
	end

	task.wait(.05)

	runCommand("re")	

end, {"toolbring", "tbring"}, 3)

addCommand("skydive", function(plrs)
	local hum = character:FindFirstChild("Humanoid")
	if not hum then return end
	local hrp = character:FindFirstChild("HumanoidRooPart") or hum.RootPart
	if not hrp then return end

	local oldPos = hrp.CFrame
	local cloneHum = hum:Clone()
	local tools = {}

	for i,v in pairs(character:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end

	for i,v in pairs(localPlayer.Backpack:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end

	if #tools == 0 then return notify("Error", "Tools are required", 5) end

	runCommand("unfly")

	task.wait()

	delete(hum)
	repeat task.wait() until hum.Parent ~= character
	cloneHum.Parent = character

	task.wait(.1)

	local targetCount = 1
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		local tchar = v.Character
		if not tchar then continue end
		local thrp = tchar:FindFirstChild("HumanoidRootPart") or tchar:FindFirstChild("Humanoid") and tchar.Humanoid.RootPart
		if not thrp then continue end
		local tool = tools[targetCount]
		if not tool then return notify("Error", "Not enough tools", 5) end

		cloneHum:EquipTool(tool)
		repeat task.wait() until tool.Parent == character
		task.wait()

		local attempts = 0
		local tPos = hrp.CFrame * CFrame.new(0,2000,0)
		repeat
			thrp.CFrame = tool.Handle.CFrame
			hrp.CFrame = tPos
			attempts += 1
			task.wait()
		until tool.Parent ~= character or attempts > 100
		hrp.CFrame = tPos
		task.wait(.25)
		delete(tool)
		targetCount += 1
		task.wait()
	end

	hrp.CFrame = oldPos

	task.wait(.2)

	runCommand("re")	

end, {}, 1)

addCommand("bring", function(plrs)
	local hum = character:FindFirstChild("Humanoid")
	if not hum then return end
	local hrp = character:FindFirstChild("HumanoidRooPart") or hum.RootPart
	if not hrp then return end

	local oldPos = hrp.CFrame
	local cloneHum = hum:Clone()
	local tools = {}

	for i,v in pairs(character:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end

	for i,v in pairs(localPlayer.Backpack:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end

	if #tools == 0 then return notify("Error", "Tools are required", 5) end

	runCommand("unfly")

	task.wait()

	delete(hum)
	repeat task.wait() until hum.Parent ~= character
	cloneHum.Parent = character

	task.wait(.1)

	local targetCount = 1
	for i,v in pairs(plrs) do
		if v == localPlayer then continue end
		local tchar = v.Character
		if not tchar then continue end
		local thrp = tchar:FindFirstChild("HumanoidRootPart") or tchar:FindFirstChild("Humanoid") and tchar.Humanoid.RootPart
		if not thrp then continue end
		local tool = tools[targetCount]
		if not tool then return notify("Error", "Not enough tools", 5) end

		cloneHum:EquipTool(tool)
		repeat task.wait() until tool.Parent == character
		task.wait()

		local attempts = 0
		repeat
			thrp.CFrame = tool.Handle.CFrame
			hrp.CFrame = oldPos
			attempts += 1
			task.wait()
		until tool.Parent ~= character or attempts > 100
		hrp.CFrame = oldPos
		task.wait(.25)
		delete(tool)
		targetCount += 1
		task.wait()
	end

	task.wait(.05)

	runCommand("re")	

end, {"toolbring", "tbring"}, 3)



--[[addCommand("control", function(plrs)
	local target = plrs[1]
	if target == localPlayer then return end
	local tchar = target.Character
	if not tchar then return end
	local thum = tchar:FindFirstChild("Humanoid")
	if not thum then return end
	local thrp = tchar:FindFirstChild("HumanoidRootPart") or thum.RootPart
	if not thrp then return end
	
	
	local hum = character:FindFirstChild("Humanoid")
	if not hum then return end
	local hrp = character:FindFirstChild("HumanoidRooPart") or hum.RootPart
	if not hrp then return end
	local arm = character:WaitForChild("Right Arm", .5) or character:FindFirstChild("RightHand", .5)
	if not arm then return end
	
	local oldPos = hrp.CFrame
	local cloneHum = hum:Clone()
	local tools = {}

	for i,v in pairs(character:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end

	for i,v in pairs(localPlayer.Backpack:GetChildren()) do
		if not (v:IsA("Tool") and v:FindFirstChild("Handle")) then continue end
		table.insert(tools, v)
	end

	if #tools == 0 then return notify("Error", "Tools are required", 5) end
	local tool = tools[1]
	
	runCommand("unfly")

	task.wait()
	
	hum:EquipTool(tool)
	local rGrip = arm:WaitForChild("RightGrip")
	tool.Grip = tool.Grip * CFrame.new(0,-1.5,3) * CFrame.Angles(math.rad(-90), 0, 0) --(hrp.CFrame:Inverse() * (CFrame.new(arm.Position) * rGrip.C0)) * CFrame.new(0, 1, -4) * CFrame.Angles(0,90,0)
	hrp.CustomPhysicalProperties = PhysicalProperties.new(100, 100, 100, 100, 100)
	hum:UnequipTools()
	repeat task.wait() until tool.Parent == localPlayer.Backpack
	hum:EquipTool(tool)
	repeat task.wait() until tool.Parent == character
	hum:UnequipTools()
	repeat task.wait() until tool.Parent == localPlayer.Backpack
	
	for i,v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
	
	task.wait(.1)
	
	delete(hum)
	repeat task.wait() until hum.Parent ~= character
	cloneHum.Parent = character
	
	cloneHum:EquipTool(tool)
	
	task.wait(.1)
	
	local attempts = 0
	repeat
		thrp.CFrame = tool.Handle.CFrame
		attempts += 1
		task.wait()
	until tool.Parent ~= character or attempts > 100
	
	if tool.Parent ~= tchar then return end
	thum.PlatformStand = true

end, {}, 3)
--]]

local function spawnHighlightBox()
	local box = Instance.new("SelectionBox")
	box.Name = "wacky selection box"
	box.Parent = gethui()
	box.Destroying:Connect(spawnHighlightBox)
	clickDeleteBox = box
end
spawnHighlightBox()

local clickDeleteHighlightCon = rs.Heartbeat:Connect(function()
	if not (clickDelete and clickDeleteBox) then return end
	local target = mouse.Target
	clickDeleteBox.Adornee = target
end)
table.insert(genv.connections, clickDeleteHighlightCon)

local clickDeleteCon = uis.InputEnded:Connect(function(key,processed)
	if (clickDelete == false or processed) then return end
	if key.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
	local target = mouse.Target
	if not target then return end
	delete(target)
end)
table.insert(genv.connections, clickDeleteCon)

addCommand("clickdelete", function()
	clickDelete = true
end, {"clickdel"}, 3)

addCommand("unclickdelete", function()
	clickDelete = false
	clickDeleteBox.Adornee = nil
end, {"unclickdel"}, 3)

addCommand("btools", function()
	sgui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
	if localPlayer.Backpack:FindFirstChild("wacky destroy tool") or (character and character:FindFirstChild("wacky destroy tool")) then
		return
	end

	local selection

	local destroyTool = Instance.new("Tool", localPlayer.Backpack)
	destroyTool.RequiresHandle = false
	destroyTool.CanBeDropped = false
	destroyTool.Name = "wacky destroy tool"
	destroyTool.ToolTip = "Click to destroy"
	destroyTool.TextureId = "rbxasset://Textures/Hammer.png"

	local selectionLoop

	destroyTool.Equipped:Connect(function()
		selection = Instance.new("SelectionBox", isTesting and localPlayer.PlayerGui or game:GetService("CoreGui"))
		table.insert(genv.connections, selection)
		selectionLoop = rs.Heartbeat:Connect(function()
			local target = mouse.Target
			if target == nil then
				selection.Adornee = nil
				return 
			end
			if selection.Parent == nil then return end
			selection.Adornee = target
		end)
		table.insert(genv.connections, selectionLoop)
	end)

	destroyTool.Unequipped:Connect(function()
		if not selection then return end
		selection:Destroy()
	end)

	destroyTool.Activated:Connect(function()
		local target = mouse.Target
		if target == nil then return end
		delete(target)
	end)

	local unweldTool = Instance.new("Tool", localPlayer.Backpack)
	unweldTool.RequiresHandle = false
	unweldTool.CanBeDropped = false
	unweldTool.Name = "wacky unweld tool"
	unweldTool.ToolTip = "Click to unweld"
	unweldTool.TextureId = "rbxassetid://4989743039"

	local selectionLoop

	unweldTool.Equipped:Connect(function()
		selection = Instance.new("SelectionBox",localPlayer.PlayerGui)
		table.insert(genv.connections, selection)
		selectionLoop = rs.Heartbeat:Connect(function()
			local target = mouse.Target
			if target == nil then
				selection.Adornee = nil
				return 
			end
			if selection.Parent == nil then return end
			selection.Adornee = target
		end)
		table.insert(genv.connections, selectionLoop)
	end)

	unweldTool.Unequipped:Connect(function()
		if not selection then return end
		selection:Destroy()
	end)

	unweldTool.Activated:Connect(function()
		local target = mouse.Target
		if target == nil then return end
		for i,v in pairs(target:GetDescendants()) do
			if not (v:IsA("Weld") or v:IsA("Attachment")) then continue end
			delete(v)
		end
	end)
end, {}, 3)

addCommand("gun", function()
	sgui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
	if not character then return end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if localPlayer.Backpack:FindFirstChild("wacky gun tool") or (character:FindFirstChild("wacky gun tool")) then
		return
	end

	local gunTool = Instance.new("Tool", localPlayer.Backpack)
	gunTool.RequiresHandle = false
	gunTool.CanBeDropped = false
	gunTool.Name = "wacky gun tool"
	gunTool.ToolTip = "Click to shoot"
	gunTool.TextureId = "rbxassetid://7246240497"

	gunTool.Activated:Connect(function()
		local target = mouse.Target
		if target == nil then return end
		delete(target)
	end)
end, {}, 3)

addCommand("require", function(plrs, input)
    -- Check if input is provided
    if not input or input == "" then
        notify("Error", "Please provide a module ID and parameters", 3)
        return
    end
    
    -- Parse the input to extract module ID and parameters
    local moduleId, params
    
    -- Check for the pattern: require(ID).gui("Name")
    local idMatch, guiParams = input:match("require%((%d+)%).gui%(\"(.-)\"%)") 
    
    if idMatch and guiParams then
        moduleId = tonumber(idMatch)
        params = guiParams
    else
        -- Try to extract just the module ID
        moduleId = tonumber(input:match("(%d+)"))
        params = ""
    end
    
    if not moduleId then
        notify("Error", "Invalid module ID format", 3)
        return
    end
    
    -- Notify user
    notify("Require", "Executing module " .. moduleId, 3)
    
    -- Create a LocalScript to execute the require
    local container = Instance.new("ScreenGui", gethui())
    container.Name = "RequireExecutor"
    
    local executeScript = Instance.new("LocalScript", container)
    executeScript.Name = "RequireScript"
    
    -- Set up the script content
    local scriptContent
    if params and params ~= "" then
        scriptContent = string.format([[
            local success, result = pcall(function()
                return require(%d).gui("%s")
            end)
            
            if not success then
                warn("Require execution failed: " .. tostring(result))
            else
                print("Require executed successfully!")
            end
        ]], moduleId, params)
    else
        scriptContent = string.format([[
            local success, result = pcall(function()
                return require(%d)
            end)
            
            if not success then
                warn("Require execution failed: " .. tostring(result))
            else
                print("Require executed successfully!")
            end
        ]], moduleId)
    end
    
    executeScript.Source = scriptContent
    
    -- Clean up after execution
    spawn(function()
        wait(5)
        if container and container.Parent then
            container:Destroy()
        end
    end)
    
    notify("Require", "Module execution initiated", 3)
end, {"req", "load"}, 3)

addCommand("fly", function(plrs)
    local hum = character:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    
    -- Create a BodyVelocity to control flight
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Name = "FlightVelocity"
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = character:FindFirstChild("HumanoidRootPart")
    
    -- Create a BodyGyro to maintain orientation
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.Name = "FlightGyro"
    bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bodyGyro.D = 50
    bodyGyro.P = 5000
    bodyGyro.CFrame = character:FindFirstChild("HumanoidRootPart").CFrame
    bodyGyro.Parent = character:FindFirstChild("HumanoidRootPart")
    
    -- Set up flight controls
    local flySpeed = 2
    local connection
    
    connection = rs.RenderStepped:Connect(function()
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            if connection then connection:Disconnect() end
            return
        end
        
        local hrp = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        
        if not hrp or not humanoid then
            if connection then connection:Disconnect() end
            return
        end
        
        -- Update gyro orientation
        bodyGyro.CFrame = CFrame.new(hrp.Position, hrp.Position + camera.CFrame.LookVector)
        
        -- Calculate movement direction
        local moveDir = humanoid.MoveDirection
        if moveDir.Magnitude > 0 then
            local camCF = camera.CFrame
            local lookVector = camCF.LookVector
            local rightVector = camCF.RightVector
            local upVector = camCF.UpVector
            
            -- Combine movement vectors based on camera orientation
            local velocity = Vector3.new(0, 0, 0)
            
            -- Forward/backward
            if moveDir.Z ~= 0 then
                velocity = velocity + lookVector * -moveDir.Z
            end
            
            -- Left/right
            if moveDir.X ~= 0 then
                velocity = velocity + rightVector * moveDir.X
            end
            
            -- Up/down (based on jump/crouch)
            if uis:IsKeyDown(Enum.KeyCode.Space) then
                velocity = velocity + Vector3.new(0, 1, 0)
            elseif uis:IsKeyDown(Enum.KeyCode.LeftControl) then
                velocity = velocity + Vector3.new(0, -1, 0)
            end
            
            -- Apply velocity
            bodyVelocity.Velocity = velocity.Unit * flySpeed * 50
        else
            -- No movement input, stop
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
        end
    end)
    
    table.insert(genv.connections, connection)
    
    notify("Flight", "Flight mode enabled", 3)
end, {"flight"}, 3)

addCommand("unfly", function()
    if character then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local bodyVelocity = hrp:FindFirstChild("FlightVelocity")
            local bodyGyro = hrp:FindFirstChild("FlightGyro")
            
            if bodyVelocity then bodyVelocity:Destroy() end
            if bodyGyro then bodyGyro:Destroy() end
        end
    end
    
    notify("Flight", "Flight mode disabled", 3)
end, {"nofly"}, 3)

addCommand("esp", function()
    -- Create ESP for all players
    local espFolder = Instance.new("Folder", gethui())
    espFolder.Name = "ESP_System"
    
    -- Function to create ESP for a player
    local function createESP(player)
        if player == localPlayer then return end
        
        local espBox = Instance.new("BoxHandleAdornment")
        espBox.Name = player.Name .. "_ESP"
        espBox.Adornee = player.Character
        espBox.AlwaysOnTop = true
        espBox.ZIndex = 10
        espBox.Size = Vector3.new(4, 5, 1)
        espBox.Transparency = 0.7
        espBox.Color3 = Color3.fromRGB(255, 0, 0)
        espBox.Parent = espFolder
        
        -- Create name label
        local billboardGui = Instance.new("BillboardGui")
        billboardGui.Name = player.Name .. "_Label"
        billboardGui.Adornee = player.Character:FindFirstChild("Head")
        billboardGui.AlwaysOnTop = true
        billboardGui.Size = UDim2.new(0, 100, 0, 40)
        billboardGui.StudsOffset = Vector3.new(0, 2, 0)
        billboardGui.Parent = espFolder
        
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "NameLabel"
        nameLabel.BackgroundTransparency = 1
        nameLabel.Size = UDim2.new(1, 0, 1, 0)
        nameLabel.Text = player.Name
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.TextStrokeTransparency = 0
        nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        nameLabel.Font = Enum.Font.SourceSansBold
        nameLabel.TextSize = 14
        nameLabel.Parent = billboardGui
        
        -- Update ESP on character changes
        player.CharacterAdded:Connect(function(char)
            espBox.Adornee = char
            billboardGui.Adornee = char:WaitForChild("Head")
        end)
    end
    
    -- Create ESP for existing players
    for _, player in pairs(players:GetPlayers()) do
        if player.Character then
            createESP(player)
        end
    end
    
    -- Create ESP for new players
    local playerAddedConnection = players.PlayerAdded:Connect(function(player)
        player.CharacterAdded:Wait()
        createESP(player)
    end)
    
    table.insert(genv.connections, playerAddedConnection)
    table.insert(genv.connections, espFolder)
    
    notify("ESP", "ESP enabled for all players", 3)
end, {"wallhack", "playeresp"}, 3)

addCommand("unesp", function()
    local espFolder = gethui():FindFirstChild("ESP_System")
    if espFolder then
        espFolder:Destroy()
    end
    
    notify("ESP", "ESP disabled", 3)
end, {"nowallhack", "noesp"}, 3)

addCommand("noclip", function()
    local noclipConnection
    
    noclipConnection = rs.Stepped:Connect(function()
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        else
            noclipConnection:Disconnect()
        end
    end)
    
    table.insert(genv.connections, noclipConnection)
    
    notify("Noclip", "Noclip enabled", 3)
end, {"phase", "ghost"}, 3)

addCommand("clip", function()
    local noclipConnection
    
    for i, connection in pairs(genv.connections) do
        if typeof(connection) == "RBXScriptConnection" and tostring(connection) == "Connection" then
            connection:Disconnect()
            table.remove(genv.connections, i)
        end
    end
    
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    
    notify("Noclip", "Noclip disabled", 3)
end, {"unphase", "unghost"}, 3)

addCommand("serverside", function()
    -- Create a server-side script execution GUI
    local serverSideGui = Instance.new("ScreenGui", gethui())
    serverSideGui.Name = "QuirkyServerSideGUI"
    serverSideGui.ResetOnSpawn = false
    serverSideGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Main frame
    local mainFrame = Instance.new("Frame", serverSideGui)
    mainFrame.Name = "MainFrame"
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BorderColor3 = Color3.fromRGB(60, 60, 60)
    mainFrame.BorderSizePixel = 2
    mainFrame.Position = UDim2.new(0.5, -200, 0.5, -150)
    mainFrame.Size = UDim2.new(0, 400, 0, 300)
    
    -- Add rounded corners
    local uiCorner = Instance.new("UICorner", mainFrame)
    uiCorner.CornerRadius = UDim.new(0, 6)
    
    -- Title bar
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    titleBar.BorderSizePixel = 0
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    
    -- Add rounded corners to title bar (top only)
    local titleCorner = Instance.new("UICorner", titleBar)
    titleCorner.CornerRadius = UDim.new(0, 6)
    
    -- Fix the bottom corners of title bar
    local bottomFrame = Instance.new("Frame", titleBar)
    bottomFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    bottomFrame.BorderSizePixel = 0
    bottomFrame.Position = UDim2.new(0, 0, 1, -6)
    bottomFrame.Size = UDim2.new(1, 0, 0, 6)
    
    -- Title text
    local titleText = Instance.new("TextLabel", titleBar)
    titleText.Name = "TitleText"
    titleText.BackgroundTransparency = 1
    titleText.Position = UDim2.new(0, 10, 0, 0)
    titleText.Size = UDim2.new(1, -20, 1, 0)
    titleText.Font = Enum.Font.SourceSansBold
    titleText.Text = "Server-Side Script Executor"
    titleText.TextColor3 = Color3.fromRGB(220, 220, 220)
    titleText.TextSize = 16
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    
    -- Close button
    local closeButton = Instance.new("TextButton", titleBar)
    closeButton.Name = "CloseButton"
    closeButton.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
    closeButton.Position = UDim2.new(1, -25, 0.5, -8)
    closeButton.Size = UDim2.new(0, 16, 0, 16)
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 14
    
    -- Add rounded corners to close button
    local closeCorner = Instance.new("UICorner", closeButton)
    closeCorner.CornerRadius = UDim.new(0, 4)
    
    -- Script input box
    local scriptBox = Instance.new("TextBox", mainFrame)
    scriptBox.Name = "ScriptBox"
    scriptBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    scriptBox.BorderColor3 = Color3.fromRGB(80, 80, 80)
    scriptBox.BorderSizePixel = 1
    scriptBox.Position = UDim2.new(0.05, 0, 0.15, 0)
    scriptBox.Size = UDim2.new(0.9, 0, 0.7, 0)
    scriptBox.Font = Enum.Font.Code
    scriptBox.PlaceholderText = "Enter your server-side script here..."
    scriptBox.Text = ""
    scriptBox.TextColor3 = Color3.fromRGB(220, 220, 220)
    scriptBox.TextSize = 14
    scriptBox.TextXAlignment = Enum.TextXAlignment.Left
    scriptBox.TextYAlignment = Enum.TextYAlignment.Top
    scriptBox.ClearTextOnFocus = false
    scriptBox.MultiLine = true
    
    -- Add rounded corners to script box
    local scriptCorner = Instance.new("UICorner", scriptBox)
    scriptCorner.CornerRadius = UDim.new(0, 4)
    
    -- Execute button
    local executeButton = Instance.new("TextButton", mainFrame)
    executeButton.Name = "ExecuteButton"
    executeButton.BackgroundColor3 = Color3.fromRGB(60, 120, 60)
    executeButton.BorderColor3 = Color3.fromRGB(100, 160, 100)
    executeButton.BorderSizePixel = 1
    executeButton.Position = UDim2.new(0.5, -75, 0.9, -15)
    executeButton.Size = UDim2.new(0, 150, 0, 30)
    executeButton.Font = Enum.Font.SourceSansBold
    executeButton.Text = "Execute"
    executeButton.TextColor3 = Color3.fromRGB(240, 240, 240)
    executeButton.TextSize = 16
    
    -- Add rounded corners to execute button
    local executeCorner = Instance.new("UICorner", executeButton)
    executeCorner.CornerRadius = UDim.new(0, 4)
    
    -- Make the frame draggable
    local dragging = false
    local dragInput
    local dragStart
    local startPos
    
    local function updateDrag(input)
        local delta = input.Position - dragStart
        mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = mainFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    titleBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            updateDrag(input)
        end
    end)
    
    -- Close button functionality
    closeButton.MouseButton1Click:Connect(function()
        serverSideGui:Destroy()
    end)
    
    -- Execute button functionality
    executeButton.MouseButton1Click:Connect(function()
        local scriptText = scriptBox.Text
        if scriptText == "" then
            notify("Error", "Script cannot be empty", 3)
            return
        end
        
        -- Execute the script with server-side permissions using the destroy remote
        if genv.foundRemote then
            -- Create a dummy instance to hold the script
            local container = Instance.new("StringValue")
            container.Name = "ServerScriptContainer"
            
            -- Create a server script that will execute the user's code
            local serverScript = Instance.new("Script", container)
            serverScript.Name = "ServerExecutor"
            serverScript.Source = scriptText
            
            -- Use the destroy remote to execute the script server-side
            genv.foundRemote:FireServer(container)
            
            notify("Success", "Script executed server-side", 3)
        else
            notify("Error", "Server-side execution not available", 3)
        end
    end)
    
    -- Add to connections for cleanup
    table.insert(genv.connections, serverSideGui)
    
    notify("Server-Side", "Script executor opened", 3)
end, {"ss", "serverscript"}, 3)

addCommand("baseplate", function()
    -- Create a baseplate to replace the entire map
    local baseplate = Instance.new("Part")
    baseplate.Name = "Baseplate"
    baseplate.Size = Vector3.new(2000, 1, 2000) -- Large enough to cover most maps
    baseplate.Position = Vector3.new(0, 0, 0)
    baseplate.Anchored = true
    baseplate.CanCollide = true
    baseplate.Material = Enum.Material.Grass
    baseplate.BrickColor = BrickColor.new("Bright green")
    baseplate.TopSurface = Enum.SurfaceType.Smooth
    baseplate.BottomSurface = Enum.SurfaceType.Smooth
    
    -- Store original workspace children to restore later if needed
    local originalChildren = {}
    for _, child in pairs(workspace:GetChildren()) do
        if child:IsA("Model") or child:IsA("BasePart") then
            if child ~= baseplate and child ~= workspace.CurrentCamera and not players:GetPlayerFromCharacter(child) then
                table.insert(originalChildren, child)
                delete(child)
            end
        end
    end
    
    -- Add the baseplate to workspace
    baseplate.Parent = workspace
    
    -- Move all players above the baseplate
    for _, player in pairs(players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.CFrame = CFrame.new(
                player.Character.HumanoidRootPart.Position.X,
                baseplate.Position.Y + baseplate.Size.Y/2 + 5, -- 5 studs above baseplate
                player.Character.HumanoidRootPart.Position.Z
            )
        end
    end
    
    notify("Baseplate", "Map replaced with baseplate", 5)
end, {"flatmap", "clearmap"}, 3)

addCommand("reanim",function() 
	task.spawn(loadReanim)
end, {"reanimate"}, 3)

--[[Add scrolling command list]]--
local scrollText = "QuirkyCMD made by smokedoutlocedout | type cmds for a list of commands | "
if not isMobile then
	scrollText ..= "press ; to open/close command bar | "
end
local charCount = 12
local spaces = 0
local scrollSpeed = 0.12 -- sec/char
local sample = scrollText..string.rep(" ", spaces)
local displayString = sample:sub(1, charCount)
local strlen = string.len(sample)

local counter = 1
local timer = 0

for i,v in pairs(scrollText:split("")) do
	if v ~= " " then continue end
	spaces += 1
end

table.insert(genv.connections, rs.Heartbeat:Connect(function(dt)
	timer += dt
	if timer > scrollSpeed then
		while timer > scrollSpeed do
			timer -= scrollSpeed
			counter = (counter + 1)%strlen
		end

		if counter + charCount <= strlen then
			displayString = sample:sub(counter, counter + charCount)
		else
			displayString = sample:sub(counter, strlen)..sample:sub(1, counter + charCount - strlen)
		end
	end

	box.PlaceholderText = (("%s"):format(displayString))
end))

--[[Sort commands alphabetically]]--
table.sort(commands, function(a,b)
	return a.name < b.name
end)

--[[Add command list logic]]--
for i,v in pairs(commands) do
	local level = v.securityLevel
	local clone = cmdTemplate:Clone()
	clone.Text = v.name .. ` ({rankNames[level]})`
	clone.Name = v.name
	clone.Visible = true
	clone.Parent = cmdsList
end

table.insert(genv.connections, closeButton.MouseButton1Click:Connect(function()
	cmdsFrame.Visible = false
end))

--[[Add drag functionality]]--
local dragging
local dragInput
local dragStart
local startPos

local lastMousePos
local lastGoalPos
local dragSpeed = 20

local function update(dt)
	if not (startPos) then return end
	if not (dragging) and (lastGoalPos) then
		cmdsFrame.Position = UDim2.new(startPos.X.Scale, lerp(cmdsFrame.Position.X.Offset, lastGoalPos.X.Offset, dt * dragSpeed), startPos.Y.Scale, lerp(cmdsFrame.Position.Y.Offset, lastGoalPos.Y.Offset, dt * dragSpeed))
		return 
	end

	local delta = (lastMousePos - uis:GetMouseLocation())
	local xGoal = (startPos.X.Offset - delta.X)
	local yGoal = (startPos.Y.Offset - delta.Y)
	lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
	cmdsFrame.Position = UDim2.new(startPos.X.Scale, lerp(cmdsFrame.Position.X.Offset, xGoal, dt * dragSpeed), startPos.Y.Scale, lerp(cmdsFrame.Position.Y.Offset, yGoal, dt * dragSpeed))	
end

cmdsFrame.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = cmdsFrame.Position
		lastMousePos = uis:GetMouseLocation()

		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

cmdsFrame.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

table.insert(genv.connections,rs.Heartbeat:Connect(update))

--[[send to game logger]]--
if not inDatabase then
	local function promptCallback(answer)
		if answer == "No" then return end
		local sg = localPlayer:FindFirstChildOfClass("StarterGear")
		if sg then
			delete(sg)
			task.wait(checkTime + mobileOffset)
		end
		if (sg and sg.Parent == localPlayer) or (isTesting == false and game:GetService("GuiService"):GetErrorCode() ~= Enum.ConnectionError.OK) then return notify("Logger error", "Game could not be logged.", 10) end
		sendGame()
		debugPrint("game sent to server")
	end

	local bindable = Instance.new("BindableFunction")
	bindable.OnInvoke = promptCallback

	sgui:SetCore("SendNotification", {
		Title = "Game logger";
		Text = "Log this game? (PLEASE TEST COMMANDS BEFORE CLICKING YES)",
		Duration = 300,
		Button1 = "Yes",
		Button2 = "No",
		Icon = "rbxassetid://71876941165953",
		Callback = bindable
	})
end

debugPrint("QuirkyCMD loaded successfully!")
